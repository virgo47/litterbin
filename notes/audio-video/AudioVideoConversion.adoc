== First - the alias!

----
alias ff='ffmpeg -hide_banner'
----

FFmpeg can be installed with `cinst -y imagemagick`.

== Fixing videos for Vegas/Movie Studio

Some MP4 videos (e.g. from Moto C Plus) can't be imported directly (different codec),
but just reconverting them is enough:

----
ff -i XY.mp4 out.mp4
----

Vegas can now import it and the file also gets considerably shorter without visible loss of quality.
At least for that phone (results probably may vary).

== Canon video conversion

Videos from Canon EOS 200D can be recoded by `ffmpeg` to much smaller files without perceivable quality loss.
Usage of `ffmpeg` is complemented with `exiftool` to preserve the important metadata (creation date, camera and lens).
The following script does the job:

----
#!/bin/bash
#
# Can handle *.MOV timelapses too, but I don't recommend to recode that one if freezed frames are important.
# For timelapses with stable/slow camera, don't change the quality, it will be compressed nicely.
# For timelapses with dynamic/shaky camera call the script with TQ set to 25 like this:
#  TQ=25 canon-video-conver.sh <params>
# Works for Q as well (for normal MP4 originals).
# Dark/grainy/noisy videos can be nearly as big as originals, they can profit from Q=20 or even 23.

set -eu

# Setting default quality for MP4 and MOV-timelapses, it will be used as CRF parameter.
# 23 is default CRF for ffmpeg, for 1080p/60fps it goes way below 10Mbps (Canon 200D original has 60Mbps).
# 17 is around 20Mbps, it also wildly depends on the style of the video (static/slow is compressed better).
: "${Q:="17"}"
: "${TQ:="17"}"

for FIN in "$@"; do
  SUF="${FIN##*.}"
  SUFL="${SUF,,}"
  FOLD="${FIN%.*}_orig.${SUFL}" # makes MP4 lowercase, so *.MP4 will not cover it anymore
  FNEW="${FIN%.*}.mp4"
  case "$SUFL" in
    mp4|mov)
      # OK
      ;;
    *)
      echo "ERROR: $FIN"
      echo "Not a supported type - you don't want me to mess with random files, do you?"
      exit 1
  esac

  CRF="$Q"
  [[ "${SUFL}" = "mov" ]] && CRF="$TQ"

  # we don't want to overwrite here, script fails if _orig file exists
  mv -n "${FIN}" "${FOLD}"

  # Use FNEW from now on, FIN would not work properly for *.MOVs
  ffmpeg.exe -hide_banner -i "${FOLD}" -crf $CRF -c:a copy "${FNEW}"
  exiftool -overwrite_original -TagsFromFile "${FOLD}" "${FNEW}"
done
----

Some unimportant metadata is lost, but camera/lens info is preserved (see "how-to" section below).
Some metadata can be related to the original video and strictly speaking invalid, I'm OK with that.
Compression is typically 2-3x for MP4 videos and varying for MOV timelapses.
`Q/TQ` is not the `quality` reported during transcoding, there is some offset.
In any case it is used as `crf` argument and lower is better quality (bigger file)
with 23 being default for `ffmpeg` which is much lower quality than original files from Canon EOS 200D.

Original files are preserved as `*_orig.*`, the extension is lower-cased not to be affected by repeated:

----
# if bash is used, it skips lowercase mp4
canon-video-conver.sh *.MP4
----

If everything is OK, they can be deleted.
If the compression is low (e.g. noisy videos tend to compress badly) or quality needs to be adjusted, they can still be used.

=== Video conversion with metadata how-to

NOTE: No quality settings are used in the examples below.
Add those and other settings as necessary in real-life scenario.
You may skip to the next section where the suitable solution is used.

Naive conversion, `exiftool` is used only for metadata reading for later comparison:

----
exiftool.exe MVI_0059.MP4 > exif-orig.txt
ffmpeg.exe -i MVI_0059.MP4 out.mp4
exiftool.exe out.mp4 > exif-ff-out-default.txt
----

* File `exif-orig.txt` has tons of metadata, creation date, camera/lens info, etc.
* `exif-ff-out-default.txt` does not even have information about creation date (shows creation of `out.mp4` instead).

Experiment based on https://video.stackexchange.com/a/26076[this answer]:

----
ffmpeg.exe -i MVI_0059.MP4 -movflags use_metadata_tags out-movflags.mp4
exiftool.exe out-movflags.mp4 > exif-ff-out-movflags.txt
----

* `exif-ff-out-movflags.txt` is barely different from `exif-ff-out-default.txt` and does not preserve creation date.

Experiment based on https://video.stackexchange.com/a/24524[the next answer] (but without `-c copy` to actually recode the video):

----
ffmpeg.exe -i MVI_0059.MP4 -map_metadata 0 out-map-metadata.mp4
exiftool.exe out-map-metadata.mp4 > exif-ff-out-map-metadata.txt
----

* `exif-ff-out-map-metadata.txt` is a bit smaller than the previous, but contains actual creation date!
It still does not contain anything about camera or lens.

Finally, https://video.stackexchange.com/a/28599[this answer] uses `exiftool`:

----
cp out.mp4 out-copy.mp4
exiftool -TagsFromFile MVI_0059.MP4 "-all:all>all:all" out-copy.mp4
exiftool out-copy.mp4 > exif-ff-out-copy.txt
----

* The output is barely better, it contains also Camera make and model, but no lens info.

But with just a slight modification we can get what we want, sometimes less is more (we'll modify `out.mp4` directly):

----
exiftool -TagsFromFile MVI_0059.MP4 out.mp4
exiftool.exe out.mp4
----

* This output is not as rich as the original (134 items, original had 245), but everything important is there.

== Audio conversion

To OGG Q7 (`anything-to-ogg-44k1-q7.sh`):

----
#!/bin/sh

# ffmpeg installed as part of imagemagick or imagemagick.app (using chocolatey)
# this version also supports better libvorbis, unlike binary from ffmpeg web

# Usage with find: find . -iname \*.flac -exec anything-to-ogg-44k1-q7.sh {} \;

# filename must by in additional {} for protection of spaces
# -vn is no video (just in case of some cover image in flac file)
# -y to overwrite file
ffmpeg.exe -i "${1}" -ar 44100 -vn -codec:a libvorbis -qscale:a 7 -y "${1%.*}.ogg"
----

To MP3 for players that don't support OGG or FLAC.
This one is more sophisticated, it doesn't override original files and allows directory as the
last argument (`anything-to-mp3.sh`):

----
#!/bin/sh
# takes list of files to convert, can be ogg or any other format
# last param can be output dir (created if necessary, defaults to basedir of input file)
#
# ffmpeg installed as part of imagemagick or imagemagick.app (using chocolatey)
# this version also supports better libvorbis, unlike binary from ffmpeg web
#
# Usage with find: find . -name \*.flac -exec ./anything-to-mp3.sh {} \;
# filename must by in additional {} for protection of spaces
# -vn is no video (just in case of some cover image in flac file)
# -y to overwrite the output file (input file is not changed of course)
#
# Example:
# anything-to-mp3.sh /f/music/ABBA/1979\ Voulez-Vous/*.ogg "ABBA 1979 Voluez-Vous"
#
# Example for multiple albums with output directory per album:
# for DIR in /f/music/Beatles/19[67]*; do
#   OUT="Beatles - "`basename "$DIR"`; anything-to-mp3.sh "$DIR"/*.mp3 "$OUT"
# done

# finds last argument: https://stackoverflow.com/a/1853993/658826
for last; do true; done

if [ -d "$last" -o ! -f "$last" ]; then
  OUTDIR="$last"
  mkdir -p "$OUTDIR"
  echo "Output to: $OUTDIR"

  # Setting new arg list without the last arg (only files to convert are there now)
  set -- "${@:1:$(($#-1))}"
fi

while [ -n "$1" ]; do
  # if we get to the last param that is used as output dir, we can exit (not necessary after set above)
  #[ "$OUTDIR" = "$1" ] && exit

  OUT="${1%.*}.mp3"
  if [ -n "$OUTDIR" ]; then
    OUT="$OUTDIR/"`basename "$OUT"`
  fi
  if [ "${1}" = "${OUT}" ]; then
    echo "Input and output file is the same! Exiting..."
    exit
  fi

  # quality 4~165kbps, 5~130 (lower is better): https://trac.ffmpeg.org/wiki/Encode/MP3
  # ffmpeg has its own quoting system, doesn't work well with single-quotes, so we redirect
  ffmpeg.exe -i pipe: -ar 44100 -vn -codec:a libmp3lame -qscale:a 4 -y "${OUT}" < "$1"

  shift
done
----
